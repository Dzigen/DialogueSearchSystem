from dataclasses import dataclass
from typing import DefaultDict
from ruamel.yaml import YAML

default_stop = DefaultDict(list)
@dataclass
class SummarizerConfig:


###################### ОБЩИЕ ГИПЕРПАРАМЕТРЫ ##################################################

   stream: bool = True                    # Нужно ли использовать потоковую передачу данных.
   keep_alive: bool = True                # Нужно ли поддерживать активное соединение после выполнения запроса. 
   num_thread: int = 8                    # Количество потоков для обработки запросов.
   num_batch: int = 2                     # Количество запросов, обрабатываемых моделью одновременно.

###################### ГИПЕРПАРАМЕТРЫ ##################################################

   assist_prompt: str = "Твоя база знаний, все ответы генерируются на основе текста ниже:"
   system_prompt: str = "Ты вопросно-ответная система. Все ответы генерируешь на русском языке. Отвечай коротко по вопросам."

   num_ctx: int = 1024                    # Размер контекста, который модель может использовать.
   num_keep: int = 5                      # Количество предложений или вариантов ответа, которые модель должна сохранить перед выбором одного из них.
   seed: int = 42                         # Задает начальное состояние для генератора случайных чисел, что позволяет получать повторяемые результаты при одинаковых условиях.
   num_predict: int = 100                 # Количество предсказываемых токенов при генерации текста.

   tfs_z: float = 0.5                     # Настройка, связанная с температурой в теории мягкого максимума.
   temperature: float = 0.8               # Параметр, управляющий разнообразием генерируемого текста. Более высокая температура приводит к более случайному выбору токенов.
   mirostat_tau: float = 0.8              # Параметр miRoStaT, связанный с температурой.
   mirostat_eta: float = 0.6              # Параметр miRoStaT, связанный с разнообразием генерации.

   top_k: int = 20                        # Параметр, используемый для ограничения выбора токенов только на основе топ-K наиболее вероятных токенов.
   top_p: float = 0.9                     # Параметр, используемый для ограничения выбора токенов только на основе токенов с накопленной вероятностью до достижения заданного порога.

   typical_p: float = 0.7                 # Типичная вероятность токена.
   repeat_last_n: int = 33                # Количество последних предсказанных токенов, которые модель будет учитывать для обнаружения повторяющихся фрагментов
   mirostat: int = 1                      # Включение механизма miRoStaT для управления температурой и разнообразием генерации.
   

###################### ШТРАФЫ ##################################################
  
   repeat_penalty: float = 1.2            # Штраф за повторение фрагментов текста.
   presence_penalty: float = 1.5          # Штраф за повторение уже существующих ответов.
   frequency_penalty: float = 1.0         # Штраф за повторение ответов, основанный на частоте использования.
   penalize_newline: bool = True          # Включение штрафа за генерацию символа новой строки.
   #stop: DefaultDict[str, list] = ["\n", "user:"]       # Список строк, при обнаружении которых модель должна завершить генерацию текста.
   
###################### ТЕХНИЧЕСКИЕ ПАРАМЕТРЫ ##################################################
   
   f16_kv: bool = True                    # Использование половинной точности для некоторых операций с ключами.
   vocab_only: bool = False               # Использование только словаря для запросов.
   use_mmap: bool = True                  # Использование mmap для доступа к данным.
   use_mlock: bool = False                # Использование mlock для защиты памяти от страницирования.
   num_gpu: int = 1                       # Количество GPU, используемых моделью.
   main_gpu: int = 0                      # Основной GPU, используемый моделью.
   low_vram: bool = False                 # Оптимизация для работы на GPU с ограниченным объемом памяти.
   numa: bool = False                     # Включение NUMA-оптимизации для работы с несколькими узлами памяти.

   @classmethod
   def load(cls, config_path: str = 'config.yaml'):
      yaml = YAML(typ='safe')
      with open(config_path, 'r', encoding='utf-8') as fd:
         data = yaml.load(fd.read())
      return cls(**data['summarizer'])